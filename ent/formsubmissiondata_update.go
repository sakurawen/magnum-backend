// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"magnum/ent/formsubmissiondata"
	"magnum/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// FormSubmissionDataUpdate is the builder for updating FormSubmissionData entities.
type FormSubmissionDataUpdate struct {
	config
	hooks    []Hook
	mutation *FormSubmissionDataMutation
}

// Where appends a list predicates to the FormSubmissionDataUpdate builder.
func (fsdu *FormSubmissionDataUpdate) Where(ps ...predicate.FormSubmissionData) *FormSubmissionDataUpdate {
	fsdu.mutation.Where(ps...)
	return fsdu
}

// SetSubmissionID sets the "submission_id" field.
func (fsdu *FormSubmissionDataUpdate) SetSubmissionID(s string) *FormSubmissionDataUpdate {
	fsdu.mutation.SetSubmissionID(s)
	return fsdu
}

// SetFieldID sets the "field_id" field.
func (fsdu *FormSubmissionDataUpdate) SetFieldID(s string) *FormSubmissionDataUpdate {
	fsdu.mutation.SetFieldID(s)
	return fsdu
}

// SetFieldValue sets the "field_value" field.
func (fsdu *FormSubmissionDataUpdate) SetFieldValue(s string) *FormSubmissionDataUpdate {
	fsdu.mutation.SetFieldValue(s)
	return fsdu
}

// SetCreateAt sets the "create_at" field.
func (fsdu *FormSubmissionDataUpdate) SetCreateAt(t time.Time) *FormSubmissionDataUpdate {
	fsdu.mutation.SetCreateAt(t)
	return fsdu
}

// Mutation returns the FormSubmissionDataMutation object of the builder.
func (fsdu *FormSubmissionDataUpdate) Mutation() *FormSubmissionDataMutation {
	return fsdu.mutation
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (fsdu *FormSubmissionDataUpdate) Save(ctx context.Context) (int, error) {
	return withHooks[int, FormSubmissionDataMutation](ctx, fsdu.sqlSave, fsdu.mutation, fsdu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (fsdu *FormSubmissionDataUpdate) SaveX(ctx context.Context) int {
	affected, err := fsdu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (fsdu *FormSubmissionDataUpdate) Exec(ctx context.Context) error {
	_, err := fsdu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (fsdu *FormSubmissionDataUpdate) ExecX(ctx context.Context) {
	if err := fsdu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (fsdu *FormSubmissionDataUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := sqlgraph.NewUpdateSpec(formsubmissiondata.Table, formsubmissiondata.Columns, sqlgraph.NewFieldSpec(formsubmissiondata.FieldID, field.TypeString))
	if ps := fsdu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := fsdu.mutation.SubmissionID(); ok {
		_spec.SetField(formsubmissiondata.FieldSubmissionID, field.TypeString, value)
	}
	if value, ok := fsdu.mutation.FieldID(); ok {
		_spec.SetField(formsubmissiondata.FieldFieldID, field.TypeString, value)
	}
	if value, ok := fsdu.mutation.FieldValue(); ok {
		_spec.SetField(formsubmissiondata.FieldFieldValue, field.TypeString, value)
	}
	if value, ok := fsdu.mutation.CreateAt(); ok {
		_spec.SetField(formsubmissiondata.FieldCreateAt, field.TypeTime, value)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, fsdu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{formsubmissiondata.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	fsdu.mutation.done = true
	return n, nil
}

// FormSubmissionDataUpdateOne is the builder for updating a single FormSubmissionData entity.
type FormSubmissionDataUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *FormSubmissionDataMutation
}

// SetSubmissionID sets the "submission_id" field.
func (fsduo *FormSubmissionDataUpdateOne) SetSubmissionID(s string) *FormSubmissionDataUpdateOne {
	fsduo.mutation.SetSubmissionID(s)
	return fsduo
}

// SetFieldID sets the "field_id" field.
func (fsduo *FormSubmissionDataUpdateOne) SetFieldID(s string) *FormSubmissionDataUpdateOne {
	fsduo.mutation.SetFieldID(s)
	return fsduo
}

// SetFieldValue sets the "field_value" field.
func (fsduo *FormSubmissionDataUpdateOne) SetFieldValue(s string) *FormSubmissionDataUpdateOne {
	fsduo.mutation.SetFieldValue(s)
	return fsduo
}

// SetCreateAt sets the "create_at" field.
func (fsduo *FormSubmissionDataUpdateOne) SetCreateAt(t time.Time) *FormSubmissionDataUpdateOne {
	fsduo.mutation.SetCreateAt(t)
	return fsduo
}

// Mutation returns the FormSubmissionDataMutation object of the builder.
func (fsduo *FormSubmissionDataUpdateOne) Mutation() *FormSubmissionDataMutation {
	return fsduo.mutation
}

// Where appends a list predicates to the FormSubmissionDataUpdate builder.
func (fsduo *FormSubmissionDataUpdateOne) Where(ps ...predicate.FormSubmissionData) *FormSubmissionDataUpdateOne {
	fsduo.mutation.Where(ps...)
	return fsduo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (fsduo *FormSubmissionDataUpdateOne) Select(field string, fields ...string) *FormSubmissionDataUpdateOne {
	fsduo.fields = append([]string{field}, fields...)
	return fsduo
}

// Save executes the query and returns the updated FormSubmissionData entity.
func (fsduo *FormSubmissionDataUpdateOne) Save(ctx context.Context) (*FormSubmissionData, error) {
	return withHooks[*FormSubmissionData, FormSubmissionDataMutation](ctx, fsduo.sqlSave, fsduo.mutation, fsduo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (fsduo *FormSubmissionDataUpdateOne) SaveX(ctx context.Context) *FormSubmissionData {
	node, err := fsduo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (fsduo *FormSubmissionDataUpdateOne) Exec(ctx context.Context) error {
	_, err := fsduo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (fsduo *FormSubmissionDataUpdateOne) ExecX(ctx context.Context) {
	if err := fsduo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (fsduo *FormSubmissionDataUpdateOne) sqlSave(ctx context.Context) (_node *FormSubmissionData, err error) {
	_spec := sqlgraph.NewUpdateSpec(formsubmissiondata.Table, formsubmissiondata.Columns, sqlgraph.NewFieldSpec(formsubmissiondata.FieldID, field.TypeString))
	id, ok := fsduo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "FormSubmissionData.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := fsduo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, formsubmissiondata.FieldID)
		for _, f := range fields {
			if !formsubmissiondata.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != formsubmissiondata.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := fsduo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := fsduo.mutation.SubmissionID(); ok {
		_spec.SetField(formsubmissiondata.FieldSubmissionID, field.TypeString, value)
	}
	if value, ok := fsduo.mutation.FieldID(); ok {
		_spec.SetField(formsubmissiondata.FieldFieldID, field.TypeString, value)
	}
	if value, ok := fsduo.mutation.FieldValue(); ok {
		_spec.SetField(formsubmissiondata.FieldFieldValue, field.TypeString, value)
	}
	if value, ok := fsduo.mutation.CreateAt(); ok {
		_spec.SetField(formsubmissiondata.FieldCreateAt, field.TypeTime, value)
	}
	_node = &FormSubmissionData{config: fsduo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, fsduo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{formsubmissiondata.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	fsduo.mutation.done = true
	return _node, nil
}
